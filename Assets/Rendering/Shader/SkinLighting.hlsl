#ifndef UNIVERSAL_SKINLIGHTING_INCLUDED
#define UNIVERSAL_SKINLIGHTING_INCLUDED

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/BSDF.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Deprecated.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceData.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"

//#include "CustomLitForwardPass.hlsl"

#define UNITY_PI            3.14159265359f

float _CurvatureScale;
float _NormalBlurredBias;
float4 _SkinShadowBias;
float _Glossiness;
float _SpecularIntensity;
float _DiffuseEnvironmentAmount;
float _SpecularEnvironmentAmount;

TEXTURE2D(_SSSLUT);                 SAMPLER(sampler_SSSLUT);
TEXTURE2D(_SkinMask);               SAMPLER(sampler_SkinMask);
TEXTURE2D(_DatasTex);               SAMPLER(sampler_DatasTex);
TEXTURE2D(_ShadowTex_LUT);          SAMPLER(sampler_ShadowTex_LUT);
TEXTURE2D(_SpecularTex);            SAMPLER(sampler_SpecularTex);
TEXTURE2D(_SpecularMaskTex);        SAMPLER(sampler_SpecularMaskTex);
TEXTURE3D(_DiffuseEnvironment);     SAMPLER(sampler_DiffuseEnvironment);
TEXTURE3D(_SpecularEnvironment);    SAMPLER(sampler_SpecularEnvironment);


float3 EvaluateDiffuseLight(float3 lightDir, float3 albedo, float3 normalGeom, float3 normalShade, \
    float3 normalBlurred, float curvature, float shadow, Light mainLight, InputData inputData)
{
    
    float2 _CurvatureBias = float2(1, 0);

    float NoL_BlurredUnclamped = (dot(normalize(normalBlurred), normalize(lightDir)));

    float curvatureScaled = curvature * _CurvatureBias.x + _CurvatureBias.y;

    half cuv = saturate(_CurvatureScale * 0.01 * (length(fwidth(normalGeom)) / length(fwidth(inputData.positionWS))));

    float2 uvCurvature = float2(NoL_BlurredUnclamped * 0.5 + 0.5, cuv);

    float3 rgbCurvature = SAMPLE_TEXTURE2D(_SSSLUT, sampler_SSSLUT, uvCurvature) * 0.5 - 0.25;

    //return float3(NoL_BlurredUnclamped, NoL_BlurredUnclamped, NoL_BlurredUnclamped);

    //return float3(cuv, cuv, cuv);

    //return float3(curvatureScaled, curvatureScaled, curvatureScaled);

    //return rgbCurvature;

    // Normal map scattering using separate normals for R, G, B; here, G and B
    // normals are generated by lerping between the specular and R normals.
    // The lerp factor to generate the G and B normals is increased near the light/dark edge,
    // to try to prevent bumps from showing up as too blue.
    // This will be more complex when arbitrary diffusion profiles are supported.
    float normalSmoothFactor = saturate(1.0 - NoL_BlurredUnclamped);

    //return float3(normalSmoothFactor, normalSmoothFactor, normalSmoothFactor);

    normalSmoothFactor *= normalSmoothFactor;

    float3 normalShadeG = normalize(lerp(normalShade, normalBlurred, 0.3 + 0.7 * normalSmoothFactor));

    //return normalShade;

    float3 normalShadeB = normalize(lerp(normalShade, normalBlurred, normalSmoothFactor));
    float NoL_ShadeG = saturate(dot(normalShadeG, lightDir));
    float NoL_ShadeB = saturate(dot(normalShadeB, lightDir));
    float3 rgbNoL = float3(saturate(NoL_BlurredUnclamped), NoL_ShadeG, NoL_ShadeB);

    //return rgbNoL;

    float3 rgbSSS = saturate(rgbCurvature + rgbNoL);

    //return rgbSSS;

    float NoL = saturate(dot(normalGeom, lightDir));
    float2 uvShadow = { shadow, NoL * _SkinShadowBias.x + _SkinShadowBias.y };

    float3 rgbShadow = SAMPLE_TEXTURE2D(_ShadowTex_LUT, sampler_ShadowTex_LUT, uvShadow);

    half3 ambient = half3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
    
    float3 rgbLightDiffuse = ambient + mainLight.color.rgb * rgbSSS * rgbShadow;

    //return float3(shadow, shadow, shadow);

    //return float3(NoL, NoL, NoL);

    //return float3(NoL*shadow, NoL*shadow, NoL*shadow);

    //return rgbShadow;
        
    
    //#ifdef FORWARD_BASE_PASS

	    // IBL Diffuse
        float ambienLight = 0;
        float3 normalAmbient0 = normalBlurred;
        float3 normalAmbient1 = normalize(lerp(normalShade, normalBlurred, 0.3));
        float3 normalAmbient2 = normalShade;

        float3 IBL_Diffuse = float3(
		    SAMPLE_TEXTURECUBE(_DiffuseEnvironment, sampler_DiffuseEnvironment, normalAmbient0).r,
		    SAMPLE_TEXTURECUBE(_DiffuseEnvironment, sampler_DiffuseEnvironment, normalAmbient1).g,
		    SAMPLE_TEXTURECUBE(_DiffuseEnvironment, sampler_DiffuseEnvironment, normalAmbient2).b);

        ambienLight = IBL_Diffuse;

        rgbLightDiffuse += IBL_Diffuse * _DiffuseEnvironmentAmount;

    //#endif
    
    
    float3 rgbLitDiffuse = albedo * rgbLightDiffuse;
    
    return rgbLitDiffuse;
}

float3 EvaluateSpecularIBL(float gloss, float3 viewDir, float3 normalShade, float specReflectance, float specLobeBlend, float NoV)
{
    float3 vecReflect = reflect(-viewDir, normalShade);
    float gloss0 = gloss;
    float gloss1 = saturate(2.0 * gloss);
    float fresnelIBL0 = lerp(specReflectance, 1.0, pow(1.0 - NoV, 5.0) / (-3.0 * gloss0 + 4.0));
    float mipLevel0 = -9.0 * gloss0 + 9.0;
    float3 iblSpec0 = fresnelIBL0 * SAMPLE_TEXTURECUBE_LOD(_SpecularEnvironment, sampler_SpecularEnvironment, vecReflect, mipLevel0);
    float fresnelIBL1 = lerp(specReflectance, 1.0, pow(1.0 - NoV, 5.0) / (-3.0 * gloss1 + 4.0));
    float mipLevel1 = -9.0 * gloss1 + 9.0;
    float3 iblSpec1 = fresnelIBL1 * SAMPLE_TEXTURECUBE_LOD(_SpecularEnvironment, sampler_SpecularEnvironment, vecReflect, mipLevel1);

    return lerp(iblSpec0, iblSpec1, specLobeBlend) * _SpecularEnvironmentAmount;
}

float3 EvaluateSpecularLight(float3 lightDir, float2 uv, float3 normalGeom, float3 normalShade, float3 viewDir, \
    float specReflectance, float gloss, float shadow, Light mainLight)
{				
    float3 lightColor = mainLight.color.rgb;

    float3 halfVec = normalize(lightDir + viewDir);
    float NoL = saturate(dot(normalShade, lightDir));
    float NoH = saturate(dot(normalShade, halfVec));
    float LoH = dot(lightDir, halfVec);
    float NoV = saturate(dot(normalShade, viewDir));
    float specPower = exp2(gloss * 13.0);

	// Evaluate NDF and visibility function
	// Two-lobe Blinn-Phong, with double gloss on second lobe
    float specLobeBlend = 0.05;
    float specPower0 = specPower;
    float specPower1 = specPower * specPower;
				
    float ndf0 = pow(NoH, specPower0) * (specPower0 + 2.0) * 0.5;
    float schlickSmithFactor0 = rsqrt(specPower0 * (UNITY_PI * 0.25) + (UNITY_PI * 0.5));
    float visibilityFn0 = 0.25 / (lerp(schlickSmithFactor0, 1, NoL) * lerp(schlickSmithFactor0, 1, NoV));

    float ndf1 = pow(NoH, specPower1) * (specPower1 + 2.0) * 0.5;
    float schlickSmithFactor1 = rsqrt(specPower1 * (UNITY_PI * 0.25) + (UNITY_PI * 0.5));
    float visibilityFn1 = 0.25 / (lerp(schlickSmithFactor1, 1, NoL) * lerp(schlickSmithFactor1, 1, NoV));
    float ndfResult = lerp(ndf0 * visibilityFn0, ndf1 * visibilityFn1, specLobeBlend);

    float fresnel = lerp(specReflectance, 1.0, pow(1.0 - LoH, 5.0));
    float specResult = ndfResult * fresnel;
    
    float edgeDarken = saturate(5.0 * dot(normalGeom, lightDir));
    float3 rgbLitSpecular = lightColor * NoL * edgeDarken * specResult * shadow;
				
	// IBL Spec
    float3 IBL_Specular = EvaluateSpecularIBL(gloss, viewDir, normalShade, specReflectance, specLobeBlend, NoV);

    rgbLitSpecular += 0;

    // Specular Mask
    //float specularMask = tex2D(_SpecularMaskTex, uv).r;

    //return rgbLitSpecular * specularMask;

    return rgbLitSpecular;
}

half4 SkinLighting(InputData inputData, SurfaceData surfaceData, float2 uv, float3 vertNormalWS, \
    float3 normalMaped, float3 normalBlurred, float3 viewDirWS)
{
#if defined(SHADOWS_SHADOWMASK) && defined(LIGHTMAP_ON)
    half4 shadowMask = inputData.shadowMask;
#elif !defined (LIGHTMAP_ON)
    half4 shadowMask = unity_ProbesOcclusion;
#else
    half4 shadowMask = half4(1, 1, 1, 1);
#endif

    Light mainLight = GetMainLight(inputData.shadowCoord, inputData.positionWS, shadowMask);

    float3 datas = SAMPLE_TEXTURE2D(_DatasTex, sampler_DatasTex, uv);

    //return half4(datas.r, datas.r, datas.r, 1);

    //return half4(normalBlurred, 1);

    half3 ambient = 0;//half3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);

    float3 rgbLitDiffuse = EvaluateDiffuseLight(mainLight.direction, surfaceData.albedo, \
        vertNormalWS, normalMaped, normalBlurred, datas.r, mainLight.shadowAttenuation, mainLight, inputData);// * datas.g;

    float specReflectance = SAMPLE_TEXTURE2D(_SpecularTex, sampler_SpecularTex, uv);

    float3 rgbLitSpecular = EvaluateSpecularLight(mainLight.direction, uv, vertNormalWS, inputData.normalWS, viewDirWS, \
        specReflectance, _Glossiness, mainLight.shadowAttenuation, mainLight);// * datas.g;

    rgbLitSpecular *= _SpecularIntensity;

    //return float4(0,0,0,0);

    return half4(ambient + rgbLitDiffuse + rgbLitSpecular, 1);
}


#endif
